for(k in 1:noRepeats){
#print(length(retObj.list[[k]]))
main.str <- as.character(permutations.v[k])
hist(retObj.list[[k]]$permutedRefCor, breaks = 100, main = main.str, xlim = xlimit)
}
dev.off()
WIDTH <- 8
HEIGHT <- 12
figname <- paste(figdir, 'pValues-CL1-', WIDTH, 'x', HEIGHT,'.pdf', sep = '')
pdf(file = figname, width = WIDTH, height = HEIGHT, paper = 'special')
par(mfcol = c(9, 1))
par(oma=c(3,3,3,3)) # b, l, t, r - all sides have 3 lines of space - outer margin
par(mar=c(1,1,1,1) + 0.1) # b, l, t, r - inner margin
for(k in 1:noRepeats){
#print(length(retObj.list[[k]]))
main.str <- as.character(permutations.v[k])
plot(retObj.list[[k]]$pValueMat[,1], xlab='', xaxt='n', main=main.str)
}
dev.off()
WIDTH <- 12
HEIGHT <- 8
figname <- paste(figdir, 'pValues-CL1-1K-vs-100K-', WIDTH, 'x', HEIGHT,'.pdf', sep = '')
pdf(file = figname, width = WIDTH, height = HEIGHT, paper = 'special')
par(mfcol = c(2, 1))
par(oma=c(3,3,3,3)) # b, l, t, r - all sides have 3 lines of space - outer margin
par(mar=c(1,1,1,1) + 0.1) # b, l, t, r - inner margin
main.str <- as.character(permutations.v[1])
plot(retObj.list[[1]]$pValueMat[,1], xlab='', xaxt='n', main=main.str)
main.str <- as.character(permutations.v[9])
plot(retObj.list[[9]]$pValueMat[,1], xlab='', xaxt='n', main=main.str)
dev.off()
nClusters <- length(unique(clusterCut))
nModelsKO <- dim(dataSimulation)[2]
n.gene <- dim(dataSimulation)[1]
pValueMat <- matrix(0, nrow = nModelsKO, ncol = nClusters)
View(pValueMat)
nModelsKO
dim(dataSimulation)
randomModels <-  matrix(rep(seq_len(n.gene), permutations),
nrow = n.gene, ncol = permutations)
length(nModelsKO)
nModelsKO
dim(randomModels)
randomModels
dim(randomModels)
randomModels
class(randomModels)
randomModels <-  matrix(rep(seq_len(n.gene), permutations),
nrow = n.gene, ncol = permutations)
View(randomModels)
randomModels <- apply(randomModels, 2, sample)
View(randomModels)
rowSums(randomModels)
colSums(randomModels)
head(rowSdDiffs())
head(rowSums(randomModels))
class(randomModels)
dim(randomModels)
t=rep(seq_len(n.gene), permutations)
length(t)
permutedRefCor <- cor(randomModels, dataReference, method = corMethod)
dim(permutedRefCor)
seq_len(nClusters)
randomModels <-  matrix(rep(seq_len(n.gene), permutations),
nrow = n.gene, ncol = permutations)
circuit_idx <- '0.09-32-0.85' # top 1st circuit - 29 nodes
fr <- strsplit(circuit_idx, split = '-')[[1]][1]
top.TFs.count <- strsplit(circuit_idx, split = '-')[[1]][2]
coreTFs <- coreTFs.list[[fr]][[top.TFs.count]][['COMB']]
targetDB = targetDB.list[[fr]]
length(coreTFs)
coreTFs <- intersect(coreTFs, names(targetDB))
length(coreTFs)
a = TF_Activity(tfs = coreTFs,
GSDB = targetDB,
eset = eset.brain_array,
DErslt = de.results  #DErslt=de.results$Overall
)
data.REF <- a$all_activities
racipe <- readRDS(file = paste('../../networks/circuits.sim/circuit_simulated_', circuit_idx, '.rds', sep = ''))
racipe <- sracipeNormalize(racipe)
data.sim <- assay(racipe,1)
dataReference = data.REF
dataSimulation = data.sim
clusterCut = clusterCut.REF
nClusters = NUM_CLUSTERS
pValue=0.05
permutations=hS.PERMUTATIONS
corMethod = "spearman"
clusterMethod = "ward.D2"
method = "pvalue"
buffer = 0.001
permutMethod = "simulation"
returnData = T
commonGenes <- intersect(rownames(dataSimulation), rownames(dataReference))
if(length(commonGenes) == 0) {
message(" No Common genes found between the simulated and reference data.")
return()
}
if(is.null(colnames(dataReference))){
colnames(dataReference) <- seq_len(ncol(dataReference))
}
if(is.null(colnames(dataSimulation))){
colnames(dataSimulation) <- seq_len(ncol(dataSimulation))
}
message("Calculating the similarity index")
n.models <- dim(dataReference)[2]
nModelsKO <- dim(dataSimulation)[2]
if (missing(permutations)) {
permutations = 1000
}
if (missing(corMethod)) {
corMethod <- "spearman"
}
refCor <- cor((dataReference), method = corMethod)
if (missing(clusterCut)) {
if(missing(nClusters)){
stop("Please specify the number of clusters using nClusters or
cluster assignments using clusterCut")
}
# cluster the reference data if the clutering assignments has not been
# provided.
distance <- as.dist((1-refCor)/2)
clusters <- hclust(distance, method = clusterMethod)
#plot(clusters)
clusterCut <- cutree(clusters, nClusters)
} else {
if(!missing(nClusters)){
warnings("Neglecting nClusters. The number of clusters will be
determined from clusterCut.")
}
nClusters <- length(unique(clusterCut))
}
dataReference <- dataReference[commonGenes, ]
dataSimulation <- dataSimulation[commonGenes, ]
refClusterVar <- c(rep(0,nClusters))
for(j in seq_len(nClusters)){
# extract pairwise distances for the samples belonging to cluster j:
# 1-cor: this makes the diagonal elements to be zeros
temp.cluster.var <- (((1 - refCor[which(clusterCut==j), which(clusterCut==j)])/2)^2)
# obtain the minimum of these pairwise distances:
refClusterVar[j] <- .ClustFunction(temp.cluster.var[upper.tri(temp.cluster.var, diag = FALSE)])
#temp.cluster.var <- NULL
#break()
}
simulated.refCor <- t(cor(dataReference, dataSimulation, method = corMethod))
if (sum(is.na(simulated.refCor)) > 0) {
message("Error in correlation. Please verify the data")
}
simulatedClusterVar <- matrix(0, nrow = nModelsKO, ncol = nClusters)
mean_dist.model2cluster <- matrix(0, nrow = nModelsKO, ncol = nClusters)
for(i in seq_len(nModelsKO)){
for(j in seq_len(nClusters)){
# from the correlations (between samples and modles), calculate the distances
# between a model and all samples in the current cluster:
temp.cluster.var <- ((1 - simulated.refCor[i, which(clusterCut==j)])/2)^2
# obtain the minimum of these distances:
simulatedClusterVar[i,j] <- .ClustFunction(temp.cluster.var)
# obtain the mean of these distances:
mean_dist.model2cluster[i,j] <- mean(temp.cluster.var)
#temp.cluster.var <- NULL
}
}
if (method == "variance") {
simulated.cluster <- matrix(0, nrow =  nModelsKO, ncol = 2)
simulated.cluster[, 2] <- apply(simulatedClusterVar,1,min)
# simulated.cluster.allowed <- simulatedClusterVar < refClusterVar
simulated.cluster[, 1] <- apply(simulatedClusterVar,1,which.min)
simulated.cluster[which(3*refClusterVar[simulated.cluster[,1]] < simulated.cluster[, 2]), 1] <- 0
simulated.cluster <- simulated.cluster[,-2]
}
if(missing(method)) {
method = "pvalue"
}
if (method == "pvalue" ) {  # here
message("pvalue method")
if(missing(permutedVar)) {
if(permutMethod == "reference"){
permutedVar <- .PermutedVar(simulated.refCor, clusterCut,
permutations, refClusterVar)
simulatedVarPValue <- .SimulatedVarPValue(permutedVar, pValue)
# rowSums(simulated.cluster.allowed)
# simulatedClusterVar.sorted <- sort(simulatedClusterVar,
# index.return = TRUE )
# simulated.cluster.allowed <- simulatedClusterVar < simulatedVarPValue
simulated.cluster <- matrix(0, nrow =  nModelsKO, ncol = 2)
simulated.cluster[, 2] <- apply(simulatedClusterVar,1,min)
simulated.cluster[, 1] <- apply(simulatedClusterVar,1,which.min)
simulated.cluster[which(simulatedVarPValue[simulated.cluster[,1]] <
simulated.cluster[, 2]), 1] <- 0
simulated.cluster <- simulated.cluster[,-2]
}else{ # and then here
message("simulation permutation")
pValueMat <- .ModelPvalue(dataSimulation, dataReference, clusterCut,
permutations, refClusterVar, corMethod,
simulatedClusterVar)
simulated.cluster <- matrix(0, nrow =  nModelsKO, ncol = 2)
simulated.cluster[, 2] <- apply(pValueMat,1,min)
simulated.cluster[, 1] <- apply(pValueMat,1,which.min)
simulated.cluster[which(simulated.cluster[,2] > pValue), 1] <- 0
simulated.cluster <- simulated.cluster[,-2]
}
} # missing(permutedVar)
}
message("simulation permutation")
pValueMat <- .ModelPvalue(dataSimulation, dataReference, clusterCut,
permutations, refClusterVar, corMethod,
simulatedClusterVar)
message("simulation permutation")
pValueMat <- .ModelPvalue(dataSimulation, dataReference, clusterCut,
permutations, refClusterVar, corMethod,
simulatedClusterVar)
simulated.cluster <- matrix(0, nrow =  nModelsKO, ncol = 2)
simulated.cluster[, 2] <- apply(pValueMat,1,min)
simulated.cluster[, 1] <- apply(pValueMat,1,which.min)
simulated.cluster[which(simulated.cluster[,2] > pValue), 1] <- 0
simulated.cluster <- simulated.cluster[,-2]
nClusters <- length(unique(clusterCut))
nModelsKO <- dim(dataSimulation)[2]
n.gene <- dim(dataSimulation)[1]
pValueMat <- matrix(0, nrow = nModelsKO, ncol = nClusters)
randomModels <-  matrix(rep(seq_len(n.gene), permutations),
nrow = n.gene, ncol = permutations)
dim(randomModels)
hS.PERMUTATIONS <- 10000
dataReference = data.REF
dataSimulation = data.sim
clusterCut = clusterCut.REF
nClusters = NUM_CLUSTERS
pValue=0.05
permutations=hS.PERMUTATIONS
corMethod = "spearman"
clusterMethod = "ward.D2"
method = "pvalue"
buffer = 0.001
permutMethod = "simulation"
returnData = T
commonGenes <- intersect(rownames(dataSimulation), rownames(dataReference))
if(length(commonGenes) == 0) {
message(" No Common genes found between the simulated and reference data.")
return()
}
if(is.null(colnames(dataReference))){
colnames(dataReference) <- seq_len(ncol(dataReference))
}
if(is.null(colnames(dataSimulation))){
colnames(dataSimulation) <- seq_len(ncol(dataSimulation))
}
message("Calculating the similarity index")
n.models <- dim(dataReference)[2]
nModelsKO <- dim(dataSimulation)[2]
if (missing(permutations)) {
permutations = 1000
}
if (missing(corMethod)) {
corMethod <- "spearman"
}
refCor <- cor((dataReference), method = corMethod)
if (missing(clusterCut)) {
if(missing(nClusters)){
stop("Please specify the number of clusters using nClusters or
cluster assignments using clusterCut")
}
# cluster the reference data if the clutering assignments has not been
# provided.
distance <- as.dist((1-refCor)/2)
clusters <- hclust(distance, method = clusterMethod)
#plot(clusters)
clusterCut <- cutree(clusters, nClusters)
} else {
if(!missing(nClusters)){
warnings("Neglecting nClusters. The number of clusters will be
determined from clusterCut.")
}
nClusters <- length(unique(clusterCut))
}
dataReference <- dataReference[commonGenes, ]
dataSimulation <- dataSimulation[commonGenes, ]
refClusterVar <- c(rep(0,nClusters))
for(j in seq_len(nClusters)){
# extract pairwise distances for the samples belonging to cluster j:
# 1-cor: this makes the diagonal elements to be zeros
temp.cluster.var <- (((1 - refCor[which(clusterCut==j), which(clusterCut==j)])/2)^2)
# obtain the minimum of these pairwise distances:
refClusterVar[j] <- .ClustFunction(temp.cluster.var[upper.tri(temp.cluster.var, diag = FALSE)])
#temp.cluster.var <- NULL
#break()
}
simulated.refCor <- t(cor(dataReference, dataSimulation, method = corMethod))
if (sum(is.na(simulated.refCor)) > 0) {
message("Error in correlation. Please verify the data")
}
simulatedClusterVar <- matrix(0, nrow = nModelsKO, ncol = nClusters)
mean_dist.model2cluster <- matrix(0, nrow = nModelsKO, ncol = nClusters)
for(i in seq_len(nModelsKO)){
for(j in seq_len(nClusters)){
# from the correlations (between samples and modles), calculate the distances
# between a model and all samples in the current cluster:
temp.cluster.var <- ((1 - simulated.refCor[i, which(clusterCut==j)])/2)^2
# obtain the minimum of these distances:
simulatedClusterVar[i,j] <- .ClustFunction(temp.cluster.var)
# obtain the mean of these distances:
mean_dist.model2cluster[i,j] <- mean(temp.cluster.var)
#temp.cluster.var <- NULL
}
}
if (method == "variance") {
simulated.cluster <- matrix(0, nrow =  nModelsKO, ncol = 2)
simulated.cluster[, 2] <- apply(simulatedClusterVar,1,min)
# simulated.cluster.allowed <- simulatedClusterVar < refClusterVar
simulated.cluster[, 1] <- apply(simulatedClusterVar,1,which.min)
simulated.cluster[which(3*refClusterVar[simulated.cluster[,1]] < simulated.cluster[, 2]), 1] <- 0
simulated.cluster <- simulated.cluster[,-2]
}
if(missing(method)) {
method = "pvalue"
}
if (method == "pvalue" ) {  # here
message("pvalue method")
if(missing(permutedVar)) {
if(permutMethod == "reference"){
permutedVar <- .PermutedVar(simulated.refCor, clusterCut,
permutations, refClusterVar)
simulatedVarPValue <- .SimulatedVarPValue(permutedVar, pValue)
# rowSums(simulated.cluster.allowed)
# simulatedClusterVar.sorted <- sort(simulatedClusterVar,
# index.return = TRUE )
# simulated.cluster.allowed <- simulatedClusterVar < simulatedVarPValue
simulated.cluster <- matrix(0, nrow =  nModelsKO, ncol = 2)
simulated.cluster[, 2] <- apply(simulatedClusterVar,1,min)
simulated.cluster[, 1] <- apply(simulatedClusterVar,1,which.min)
simulated.cluster[which(simulatedVarPValue[simulated.cluster[,1]] <
simulated.cluster[, 2]), 1] <- 0
simulated.cluster <- simulated.cluster[,-2]
}else{ # and then here
message("simulation permutation")
pValueMat <- .ModelPvalue(dataSimulation, dataReference, clusterCut,
permutations, refClusterVar, corMethod,
simulatedClusterVar)
simulated.cluster <- matrix(0, nrow =  nModelsKO, ncol = 2)
simulated.cluster[, 2] <- apply(pValueMat,1,min)
simulated.cluster[, 1] <- apply(pValueMat,1,which.min)
simulated.cluster[which(simulated.cluster[,2] > pValue), 1] <- 0
simulated.cluster <- simulated.cluster[,-2]
}
} # missing(permutedVar)
}
message("simulation permutation")
pValueMat <- .ModelPvalue(dataSimulation, dataReference, clusterCut,
permutations, refClusterVar, corMethod,
simulatedClusterVar)
simulated.cluster <- matrix(0, nrow =  nModelsKO, ncol = 2)
simulated.cluster[, 2] <- apply(pValueMat,1,min)
simulated.cluster[, 1] <- apply(pValueMat,1,which.min)
simulated.cluster[which(simulated.cluster[,2] > pValue), 1] <- 0
simulated.cluster <- simulated.cluster[,-2]
nClusters <- length(unique(clusterCut))
nModelsKO <- dim(dataSimulation)[2]
n.gene <- dim(dataSimulation)[1]
pValueMat <- matrix(0, nrow = nModelsKO, ncol = nClusters)
randomModels <-  matrix(rep(seq_len(n.gene), permutations),
nrow = n.gene, ncol = permutations)
randomModels <- apply(randomModels, 2, sample)
randomModels <-  matrix(rep(seq_len(n.gene), permutations),
nrow = n.gene, ncol = permutations)
dim(randomModels)
tmp <- randomModels
randomModels <- apply(randomModels, 2, sample)
View(tmp)
head(colSdDiffs(tm))
head(colSums(tmp))
head(colSums(randomModels))
dim(randomModels)
dim(tmp)
dim(permutedRefCor)
permutedRefCor <- cor(randomModels, dataReference, method = corMethod)
dim(permutedRefCor)
dim(randomModels)
dim(dataReference)
View(permutedRefCor)
j=1
dist.mat <- ((1 - permutedRefCor[,which(clusterCut == j)])/2)^2
View(dist.mat)
dim(dist.mat)
clusterCut
dim(dist.mat)
m=apply(dist.mat, 1, min)
length(m)
head(m)
m
m=apply(dist.mat, 1, min)
m
length(m)
m
dim(dist.mat)
m
sort(m)
seq_len(nModelsKO)
length(seq_len(nModelsKO))
nModelsKO
dim(dist.mat )
1 - permutedRefCor[,which(clusterCut == 1)])
1 - permutedRefCor[,which(clusterCut == 1)]
d= ((1 - permutedRefCor[,which(clusterCut == 1)])/2)^2
d
dim(d)
which(clusterCut == 1)
d= ((1 - permutedRefCor[,1])/2)^2
dim(d)
d
dim(d)
length(d)
dim(dist.mat)
length(d)
m=apply(dist.mat, 1, min)
m
length(m)
length(m)
head(m)
tail(m)
m=sort(apply(dist.mat, 1, min))
m
length(m)
head(m)
tail(m)
seq_len(nModelsKO)
length(seq_len(nModelsKO))
tempVector - simulatedClusterVar[i,j])))[1] - 1)/permutations
which(abs(tempVector - simulatedClusterVar[i,j]) == min(abs(
tempVector - simulatedClusterVar[i,j])))[1] - 1
(which(abs(tempVector - simulatedClusterVar[i,j]) == min(abs(
tempVector - simulatedClusterVar[i,j])))[1] - 1)
(which(abs(tempVector - simulatedClusterVar[i,j]) == min(abs(
tempVector - simulatedClusterVar[i,j])))[1] - 1)/permutations
pval.tmp <- (which(abs(tempVector - simulatedClusterVar[i,j]) == min(abs(
tempVector - simulatedClusterVar[i,j])))[1] - 1)/permutations
pval.tmp
View(simulatedClusterVar)
tempVector - simulatedClusterVar[i,j]
abs(tempVector - simulatedClusterVar[i,j])
simulatedClusterVar[i,j]
dim(simulatedClusterVar)
which(abs(tempVector - simulatedClusterVar[i,j])
)
abs(tempVector - simulatedClusterVar[i,j]
)
abs(tempVector - simulatedClusterVar[i,j])
which(abs(tempVector - simulatedClusterVar[i,j])
abs(tempVector - simulatedClusterVar[i,j])
abs(tempVector - simulatedClusterVar[i,j])
min(abs(tempVector - simulatedClusterVar[i,j]))
which(abs(tempVector - simulatedClusterVar[i,j]) == min(abs(tempVector - simulatedClusterVar[i,j])))
which(abs(tempVector - simulatedClusterVar[i,j]) == min(abs(tempVector - simulatedClusterVar[i,j])))[1]
abs(tempVector - simulatedClusterVar[i,j])
min(abs(tempVector - simulatedClusterVar[i,j]))
which(abs(tempVector - simulatedClusterVar[i,j]) == min(abs(tempVector - simulatedClusterVar[i,j])))[1]
permutations
pval.tmp
which(abs(tempVector - simulatedClusterVar[i,j]) == min(abs(tempVector - simulatedClusterVar[i,j])))[1]
pval.tmp
which(abs(tempVector - simulatedClusterVar[i,j]) == min(abs(tempVector - simulatedClusterVar[i,j])))[1]
head(tempVector)
tail(tempVector)
length(tempVector)
dim(dist.mat)
dim(simulatedClusterVar)
for(j in seq_len(nClusters)){
# Convert the correlations to distances:
# calculate the distances between each random model in randomModels and
# each of the samples (in dataRefence) belonging to the current cluster
# (square((1- cor(v1, v2))/2) is used as a distance
# between two vectors v1 and v2):
dist.mat <- ((1 - permutedRefCor[,which(clusterCut == j)])/2)^2
# (1) calculate the minimum distance between each sample and the random models
# (2) sort these minimum distances
tempVector <- sort(apply(dist.mat, 1, .ClustFunction))
for (i in seq_len(nModelsKO)){
pValueMat[i,j] <- (which(abs(tempVector - simulatedClusterVar[i,j]) == min(abs(
tempVector - simulatedClusterVar[i,j])))[1] - 1)/permutations
#[1] as sometimes which() might satisfy for multiple values
}
}
dim(pValueMat)
pValueMat <- .ModelPvalue(dataSimulation, dataReference, clusterCut,
permutations, refClusterVar, corMethod,
simulatedClusterVar)
View(pValueMat)
simulated.cluster <- matrix(0, nrow =  nModelsKO, ncol = 2)
dim(simulated.cluster)
View(simulated.cluster)
simulated.cluster[, 2] <- apply(pValueMat,1,min)
t= apply(pValueMat,1,min)
length(t)
simulated.cluster[, 1] <- apply(pValueMat,1,which.min)
?which.min
which.min(c(2,1))
which.min(c(1,2))
which(simulated.cluster[,2] > pValue)
head(which(simulated.cluster[,2] > pValue))
simulated.cluster[which(simulated.cluster[,2] > pValue), 1] <- 0
simulated.cluster[,-2]
t=simulated.cluster[,-2]
t
class(simulated.cluster[,)
class(simulated.cluster[,-2])
simulated.cluster <- simulated.cluster[,-2]
head(simulated.cluster)
tail(simulated.cluster)
simulated.cluster
sum(simulated.cluster==0)
sum(simulated.cluster==1)
sum(simulated.cluster==2)

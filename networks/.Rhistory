networkGenes <- union(network$Source, network$Target)
length(networkGenes)
# subset expression data related to network genes
TFactivities <- t(TFactivities[networkGenes,])
dim(TFactivities)
# Infer and assign interaction types
#------------------------------------
# calculate gene expression correlations
actCor <- cor(TFactivities, method = "s")
dim(actCor)
#head(rownames(actCor))
#head(actCor, 2)
# calculate correlation between Source and Target
int.type <- integer(length = length(network$Source))
for(i in seq_along(network$Source)){
int.type[i] <- actCor[as.character(network$Source[i]), as.character(network$Target[i])]
}
# correlation
network$Cor <- int.type
# Deterimine interaction type from the Source:Target correlations
# Assign interaction sign based on correlation
# Convert correlations to interaction type
# >0: 1 (activation)
# <0: 2 (inhibition)
int.type[int.type>0] <- 1
int.type[int.type<=0] <- 2
network$Type <- int.type
# assign absolute value of correlations to MI
network$Mi <- abs(network$Cor)
# Infer CANDIDATE networks from initial network
#----------------------------------------------
print("Infer CANDIDATE networks")
networkList  <- list()
for(int.strength in int.strengths){
networkList[[as.character(int.strength)]] <- createNetworkMiValue(tmpNetwork = network,
coreTf = networkGenes,
posMi = int.strength,
negMi = int.strength,
name="net",
simulate = F)
}
#names(networkList)
#length(names(networkList))
# Remove duplicated networks based on number of nodes and number of interactions
# (apply only once)
#--------------------------------------------------------------------------------
#length(networkList)
networkList <- retain_uniq_networks(networkList)
#length(networkList)
# Refine sampled networks:
# Retain largest connected component having
# nodes more than SUBNETWORK.SIZE.TSH
##-----------------------------------------
networkList.refined <- list()
for(int.strength in names(networkList)){
print(int.strength)
network.cur <- networkList[[int.strength]]
network.comp <- select.largest.connected.subgraph(network.cur=network.cur,
network = network,
subnetwork.size.TSH = SUBNETWORK.SIZE.TSH)
if(!is.null(network.comp))
networkList.refined[[int.strength]] <- network.comp
}
names(networkList.refined)
length(names(networkList.refined))
return(networkList.refined)
}
circuits <- list()
for(fr in names(coreTFs.list)){
print(fr)
coreTFs.byTOPtfCount <- coreTFs.list[[fr]]
for(top.TFs.count in names(coreTFs.byTOPtfCount)){
print(top.TFs.count)
coreTFs.byMethod <- coreTFs.byTOPtfCount[[top.TFs.count]]
coreTFs <- coreTFs.byMethod[["COMB"]] # extract combined TFs
circuits.tmp <- infer.circuits.by.targetDB(coreTFs = coreTFs,
targetDB = targetDB.list[[fr]], #targetDB,
eset.brain_array = eset.brain_array,
de.results = de.results,
int.strengths <- INTERACTION.STRENGTHS)
# extract and save individual circuits:
for(mi.tsh in names(circuits.tmp)){
idx_name <- paste(fr, top.TFs.count, mi.tsh, sep = '-')
print(idx_name)
circuits[[idx_name]] <- circuits.tmp[[mi.tsh]]
}
break()
}
break()
}
SUBNETWORK.SIZE.TSH <- 0.80
remove(list = ls())
INTERACTION.STRENGTHS  <- seq(0.00, 0.95, 0.05)
SUBNETWORK.SIZE.TSH <- 0.80
library(igraph)
source('./functions.R')
library(sRACIPE)
library(NetAct)
outdir <- './circuits/'
dir.create(outdir)
fname.eset.brain_array <- '../data.tfs/eset.brain_array.rda'
load(fname.eset.brain_array) # loads object eset.brain_array
fname.de.results <- '../data.tfs/de.results.rda'
load(fname.de.results) # loads object de.results
coreTFs.list <- readRDS('../tfSets/data/coreTFs.rds')
names(coreTFs.list)
targetDB.list <- readRDS('../databases/targetDB.list.rds')
length(names(coreTFs.list))
cat(names(coreTFs.list))
INTERACTION.STRENGTHS  <- seq(0.00, 0.95, 0.05)
length(INTERACTION.STRENGTHS)
names(coreTFs.list)
fr=ames(coreTFs.list)[1]
fr=names(coreTFs.list)[1]
fr
coreTFs.byTOPtfCount <- coreTFs.list[[fr]]
names(coreTFs.byTOPtfCount)
cat(coreTFs.byTOPtfCount)
cat(names(coreTFs.byTOPtfCount))
length(names(coreTFs.byTOPtfCount))
11*20*15
top.TFs.count = names(coreTFs.byTOPtfCount)[1]
print(top.TFs.count)
coreTFs.byMethod <- coreTFs.byTOPtfCount[[top.TFs.count]]
coreTFs <- coreTFs.byMethod[["COMB"]] # extract combined TFs
circuits.tmp <- infer.circuits.by.targetDB(coreTFs = coreTFs,
targetDB = targetDB.list[[fr]], #targetDB,
eset.brain_array = eset.brain_array,
de.results = de.results,
int.strengths <- INTERACTION.STRENGTHS,
SUBNETWORK.SIZE.TSH=SUBNETWORK.SIZE.TSH)
names(circuits.tmp)
for(mi.tsh in names(circuits.tmp)){
idx_name <- paste(fr, top.TFs.count, mi.tsh, sep = '-')
print(idx_name)
circuits[[idx_name]] <- circuits.tmp[[mi.tsh]]
}
circuits <- list()
for(mi.tsh in names(circuits.tmp)){
idx_name <- paste(fr, top.TFs.count, mi.tsh, sep = '-')
print(idx_name)
circuits[[idx_name]] <- circuits.tmp[[mi.tsh]]
}
names(circuits)
INTERACTION.STRENGTHS  <- seq(0.00, 0.95, 0.05)
SUBNETWORK.SIZE.TSH <- 0.80
INTERACTION.STRENGTHS
INTERACTION.STRENGTHS
length(0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95)
length(0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95)
length(INTERACTION.STRENGTHS)
11*15
remove(list = ls())
circuit_metrics.sim <- read.csv(file = './results/summary.circuits.sim.sigVal.csv', row.names = 1)
source('./functions.R')
outdir <- './results/'
circuit_metrics.sim <- sortByThreeIndices(circuit_metrics.sim)
dim(circuit_metrics.sim)
min(circuit_metrics.sim$idxBoth)
max(circuit_metrics.sim$idxBoth)
min(circuit_metrics.sim$idxTrio)
max(circuit_metrics.sim$idxTrio)
write.csv(circuit_metrics.sim, file = './results/summary.circuits.sim.sorted.csv',
row.names = T, quote = F)
circuit_metrics.sim <- sortByTwoIndices(circuit_metrics.sim)
write.csv(circuit_metrics.sim, file = './results/summary.circuits.sim.sortedByAcc_AvgDist.csv',
row.names = T, quote = F)
sortByTwoIndices.acc_and_flex <- function(circuit_metrics.sim){
# sort by Accuracy:
data.sortedByAccuracy <- circuit_metrics.sim[order(circuit_metrics.sim$Accuracy, decreasing = T), ]
data.sortedByAccuracy$idxAccuracy <- 1:dim(data.sortedByAccuracy)[1]
# # sort by AvgDist:
# data.sortedByAvgDist <- data.sortedByAccuracy[order(data.sortedByAccuracy$AvgDist, decreasing = F), ]
# data.sortedByAvgDist$idxAvgDist <- 1:dim(data.sortedByAvgDist)[1]
# sort by flexibility:
data.sortedByFlexibility <- data.sortedByAccuracy[order(data.sortedByAccuracy$flexibility, decreasing = T), ]
data.sortedByFlexibility$idxFlexibility <- 1:dim(data.sortedByFlexibility)[1] # adding index
# add both indices:
data.sortedByFlexibility$idxBoth <- data.sortedByFlexibility$idxAccuracy+data.sortedByFlexibility$idxFlexibility
# sort by conjugate index:
data.sortedByBoth <- data.sortedByFlexibility[order(data.sortedByFlexibility$idxBoth, decreasing = F),]
return(data.sortedByBoth)
}
sortByThreeIndices <- function(circuit_metrics.sim){
# sort by Accuracy:
data.sortedByAccuracy <- circuit_metrics.sim[order(circuit_metrics.sim$Accuracy, decreasing = T), ]
data.sortedByAccuracy$idxAccuracy <- 1:dim(data.sortedByAccuracy)[1] # adding index
# sort by AvgDist:
data.sortedByAvgDist <- data.sortedByAccuracy[order(data.sortedByAccuracy$AvgDist, decreasing = F), ]
data.sortedByAvgDist$idxAvgDist <- 1:dim(data.sortedByAvgDist)[1]
# add both indices:
data.sortedByAvgDist$idxBoth <- data.sortedByAvgDist$idxAccuracy+data.sortedByAvgDist$idxAvgDist
# sort by flexibility:
data.sortedByFlexibility <- data.sortedByAvgDist[order(data.sortedByAvgDist$flexibility, decreasing = T), ]
data.sortedByFlexibility$idxFlexibility <- 1:dim(data.sortedByFlexibility)[1] # adding index
# add three indices:
data.sortedByFlexibility$idxTrio <- data.sortedByFlexibility$idxAccuracy+data.sortedByFlexibility$idxAvgDist + data.sortedByFlexibility$idxFlexibility
# sort by conjugate index:
data.sortedByTrio <- data.sortedByFlexibility[order(data.sortedByFlexibility$idxTrio, decreasing = F),]
return(data.sortedByTrio)
}
circuit_metrics.sim <- sortByTwoIndices(circuit_metrics.sim)
write.csv(circuit_metrics.sim, file = './results/summary.circuits.sim.sortedByAcc_avgDist.csv',
row.names = T, quote = F)
circuit_metrics.sim <- sortByTwoIndices(circuit_metrics.sim)
write.csv(circuit_metrics.sim, file = './results/summary.circuits.sim.sortedByAcc_avgDist.csv',
row.names = T, quote = F)
circuit_metrics.sim <- sortByTwoIndices.acc_and_flex(circuit_metrics.sim)
write.csv(circuit_metrics.sim,
file = './results/summary.circuits.sim.sortedByAcc_flex.csv',
row.names = T, quote = F)
sortByTwoIndices.acc_and_flex <- function(circuit_metrics.sim){
# sort by Accuracy:
data.sortedByAccuracy <- circuit_metrics.sim[order(circuit_metrics.sim$Accuracy, decreasing = T), ]
data.sortedByAccuracy$idxAccuracy <- 1:dim(data.sortedByAccuracy)[1]
# # sort by AvgDist:
# data.sortedByAvgDist <- data.sortedByAccuracy[order(data.sortedByAccuracy$AvgDist, decreasing = F), ]
# data.sortedByAvgDist$idxAvgDist <- 1:dim(data.sortedByAvgDist)[1]
# sort by flexibility:
data.sortedByFlexibility <- data.sortedByAccuracy[order(data.sortedByAccuracy$flexibility, decreasing = T), ]
data.sortedByFlexibility$idxFlexibility <- 1:dim(data.sortedByFlexibility)[1] # adding index
# add both indices:
data.sortedByFlexibility$idxBoth <- data.sortedByFlexibility$idxAccuracy+data.sortedByFlexibility$idxFlexibility
# sort by conjugate index:
data.sortedByBoth <- data.sortedByFlexibility[order(data.sortedByFlexibility$idxBoth, decreasing = F),]
return(data.sortedByBoth)
}
sortByTwoIndices.avgDist_and_flex <- function(circuit_metrics.sim){
# sort by Accuracy:
# data.sortedByAccuracy <- circuit_metrics.sim[order(circuit_metrics.sim$Accuracy, decreasing = T), ]
# data.sortedByAccuracy$idxAccuracy <- 1:dim(data.sortedByAccuracy)[1]
# # sort by AvgDist:
data.sortedByAvgDist <- circuit_metrics.sim[order(circuit_metrics.sim$AvgDist, decreasing = F), ]
data.sortedByAvgDist$idxAvgDist <- 1:dim(data.sortedByAvgDist)[1]
# sort by flexibility:
data.sortedByFlexibility <- data.sortedByAvgDist[order(data.sortedByAvgDist$flexibility, decreasing = T), ]
data.sortedByFlexibility$idxFlexibility <- 1:dim(data.sortedByFlexibility)[1] # adding index
# add both indices:
data.sortedByFlexibility$idxBoth <- data.sortedByAvgDist$idxAvgDist+data.sortedByFlexibility$idxFlexibility
# sort by conjugate index:
data.sortedByBoth <- data.sortedByFlexibility[order(data.sortedByFlexibility$idxBoth, decreasing = F),]
return(data.sortedByBoth)
}
sortByThreeIndices <- function(circuit_metrics.sim){
# sort by Accuracy:
data.sortedByAccuracy <- circuit_metrics.sim[order(circuit_metrics.sim$Accuracy, decreasing = T), ]
data.sortedByAccuracy$idxAccuracy <- 1:dim(data.sortedByAccuracy)[1] # adding index
# sort by AvgDist:
data.sortedByAvgDist <- data.sortedByAccuracy[order(data.sortedByAccuracy$AvgDist, decreasing = F), ]
data.sortedByAvgDist$idxAvgDist <- 1:dim(data.sortedByAvgDist)[1]
# add both indices:
data.sortedByAvgDist$idxBoth <- data.sortedByAvgDist$idxAccuracy+data.sortedByAvgDist$idxAvgDist
# sort by flexibility:
data.sortedByFlexibility <- data.sortedByAvgDist[order(data.sortedByAvgDist$flexibility, decreasing = T), ]
data.sortedByFlexibility$idxFlexibility <- 1:dim(data.sortedByFlexibility)[1] # adding index
# add three indices:
data.sortedByFlexibility$idxTrio <- data.sortedByFlexibility$idxAccuracy+data.sortedByFlexibility$idxAvgDist + data.sortedByFlexibility$idxFlexibility
# sort by conjugate index:
data.sortedByTrio <- data.sortedByFlexibility[order(data.sortedByFlexibility$idxTrio, decreasing = F),]
return(data.sortedByTrio)
}
cal.circuit_metrics.globally <- function(networkList){
library(igraph)
# create a matrix to save features of each circuit:
circuit.features <- c('FeatureRatio', 'TopTFs', 'AbsCor',
'Nodes', 'Interactions', 'PosInt',
'Connected', 'Transitivity', 'MeanDistance')
networkMetrics <- as.data.frame(matrix(nrow = length(circuits), ncol = length(circuit.features)))
colnames(networkMetrics) <-  circuit.features
rownames(networkMetrics) <- names(circuits)
# loop through each circuit and calculate the features of the circuit:
for(circuit_idx in names(networkList)){
feature_ratio_cutoff  <- strsplit(circuit_idx, '-', 2)[[1]][1]
no_top_tfs <- strsplit(circuit_idx, '-', 2)[[1]][2]
absCor <- strsplit(circuit_idx, '-', 2)[[1]][3]
circuit <- networkList[[circuit_idx]]
g <- graph_from_data_frame(circuit,
directed = TRUE,
vertices = NULL)
stat.vector <- c(feature_ratio_cutoff = as.numeric(feature_ratio_cutoff),
no_top_tfs = as.numeric(no_top_tfs),
absCor = as.numeric(absCor),
Nodes = length(union(circuit$Source,circuit$Target)),
Interactions = length(circuit$Source),
PosInt = length(which(circuit$Type ==1)),
Connected = igraph::is_connected(g),
Transitivity = igraph::transitivity(g),
MeanDistance = igraph::mean_distance(g, directed = TRUE,
unconnected = FALSE)
)
networkMetrics[circuit_idx, ] <- stat.vector
}
return(networkMetrics)
}
find.tpo_dup_status <- function(circuit.list){
network.similarity <- cal.network_metrics.pre_sim(networkList = circuit.list)
network.similarity.tmp <- network.similarity
network.similarity.sorted <- network.similarity[with(network.similarity, order(Nodes, Interactions, PosInt)), ]
network.similarity <- network.similarity.sorted
# Find duplicate topologies
# screening by metric node_count
node_count.similarity <- duplicated(network.similarity$Nodes)
sum(node_count.similarity)
node_count.similarity
# screening by metric interaction_count.similarity
interaction_count.similarity <- duplicated(network.similarity$Interactions)
interaction_count.similarity
sum(interaction_count.similarity)
# screening by metric posInt.similarity
posInt.similarity <- duplicated(network.similarity$PosInt)
sum(posInt.similarity)
posInt.similarity
# find duplicates
node_interaction_posInt.similarity <- node_count.similarity & interaction_count.similarity & posInt.similarity
sum(node_interaction_posInt.similarity)
network.similarity$DUP.STATUS <- node_interaction_posInt.similarity
return(network.similarity)
}
circuit_metrics.sim <- sortByTwoIndices.acc_and_flex(circuit_metrics.sim)
write.csv(circuit_metrics.sim,
file = './results/summary.circuits.sim.sortedByAcc_flex.csv',
row.names = T, quote = F)
circuit_metrics.sim <- sortByTwoIndices.avgDist_and_flex(circuit_metrics.sim)
write.csv(circuit_metrics.sim,
file = './results/summary.circuits.sim.sortedByAvgDist_flex.csv',
row.names = T, quote = F)
remove(list = ls())
circuit_metrics.sim <- read.csv(file = './results/summary.circuits.sim.sigVal.csv', row.names = 1)
source('./functions.R')
outdir <- './results/'
circuit_metrics.sim.sorted <- sortByThreeIndices(circuit_metrics.sim)
write.csv(circuit_metrics.sim.sorted,
file = './results/summary.circuits.sim.sorted.csv',
row.names = T, quote = F)
circuit_metrics.sim.sorted <- sortByTwoIndices(circuit_metrics.sim)
write.csv(circuit_metrics.sim.sorted,
file = './results/summary.circuits.sim.sortedByAcc_avgDist.csv',
row.names = T, quote = F)
circuit_metrics.sim.sorted <- sortByTwoIndices.acc_and_flex(circuit_metrics.sim)
write.csv(circuit_metrics.sim.sorted,
file = './results/summary.circuits.sim.sortedByAcc_flex.csv',
row.names = T, quote = F)
circuit_metrics.sim.sorted <- sortByTwoIndices.avgDist_and_flex(circuit_metrics.sim)
write.csv(circuit_metrics.sim.sorted,
file = './results/summary.circuits.sim.sortedByAvgDist_flex.csv',
row.names = T, quote = F)
View(circuit_metrics.sim.sorted)
View(circuit_metrics.sim)
View(circuit_metrics.sim)
data.sortedByAccuracy <- circuit_metrics.sim[order(circuit_metrics.sim$Accuracy, decreasing = T), ]
data.sortedByAccuracy$idxAccuracy <- 1:dim(data.sortedByAccuracy)[1]
View(data.sortedByAccuracy)
data.sortedByFlexibility <- data.sortedByAccuracy[order(data.sortedByAccuracy$flexibility, decreasing = T), ]
View(data.sortedByFlexibility)
data.sortedByFlexibility$idxFlexibility <- 1:dim(data.sortedByFlexibility)[1] # adding index
data.sortedByFlexibility$idxBoth <- data.sortedByFlexibility$idxAccuracy+data.sortedByFlexibility$idxFlexibility
data.sortedByBoth <- data.sortedByFlexibility[order(data.sortedByFlexibility$idxBoth, decreasing = F),]
View(data.sortedByFlexibility)
View(data.sortedByBoth)
write.csv(circuit_metrics.sim.sorted,
file = './results/summary.circuits.sim.sortedByAvgDist_flex.csv',
row.names = T, quote = F)
circuit_metrics.sim.sorted <- sortByTwoIndices.acc_and_flex(circuit_metrics.sim)
View(circuit_metrics.sim.sorted)
circuit_metrics.sim.sorted <- sortByTwoIndices.avgDist_and_flex(circuit_metrics.sim)
View(circuit_metrics.sim.sorted)
data.sortedByAvgDist <- circuit_metrics.sim[order(circuit_metrics.sim$AvgDist, decreasing = F), ]
data.sortedByAvgDist$idxAvgDist <- 1:dim(data.sortedByAvgDist)[1]
data.sortedByFlexibility$idxBoth <- data.sortedByAvgDist$idxAvgDist+data.sortedByFlexibility$idxFlexibility
View(data.sortedByBoth)
data.sortedByBoth <- data.sortedByFlexibility[order(data.sortedByFlexibility$idxBoth, decreasing = F),]
head(data.sortedByAvgDist$idxAvgDist)
head(data.sortedByFlexibility$idxFlexibility)
data.sortedByFlexibility$idxBoth <- data.sortedByFlexibility$idxAvgDist+data.sortedByFlexibility$idxFlexibility
data.sortedByBoth <- data.sortedByFlexibility[order(data.sortedByFlexibility$idxBoth, decreasing = F),]
data.sortedByFlexibility$idxBoth <- data.sortedByFlexibility$idxAvgDist+data.sortedByFlexibility$idxFlexibility
data.sortedByFlexibility$idxAvgDist
data.sortedByFlexibility$idxAccuracy
data.sortedByAvgDist <- circuit_metrics.sim[order(circuit_metrics.sim$AvgDist, decreasing = F), ]
data.sortedByAvgDist$idxAvgDist <- 1:dim(data.sortedByAvgDist)[1]
data.sortedByFlexibility <- data.sortedByAvgDist[order(data.sortedByAvgDist$flexibility, decreasing = T), ]
data.sortedByFlexibility$idxFlexibility <- 1:dim(data.sortedByFlexibility)[1] # adding index
data.sortedByFlexibility$idxBoth <- data.sortedByFlexibility$idxAvgDist+data.sortedByFlexibility$idxFlexibility
data.sortedByBoth <- data.sortedByFlexibility[order(data.sortedByFlexibility$idxBoth, decreasing = F),]
sortByTwoIndices.avgDist_and_flex <- function(circuit_metrics.sim){
# sort by Accuracy:
# data.sortedByAccuracy <- circuit_metrics.sim[order(circuit_metrics.sim$Accuracy, decreasing = T), ]
# data.sortedByAccuracy$idxAccuracy <- 1:dim(data.sortedByAccuracy)[1]
# # sort by AvgDist:
data.sortedByAvgDist <- circuit_metrics.sim[order(circuit_metrics.sim$AvgDist, decreasing = F), ]
data.sortedByAvgDist$idxAvgDist <- 1:dim(data.sortedByAvgDist)[1]
# sort by flexibility:
data.sortedByFlexibility <- data.sortedByAvgDist[order(data.sortedByAvgDist$flexibility, decreasing = T), ]
data.sortedByFlexibility$idxFlexibility <- 1:dim(data.sortedByFlexibility)[1] # adding index
# add both indices:
data.sortedByFlexibility$idxBoth <- data.sortedByFlexibility$idxAvgDist+data.sortedByFlexibility$idxFlexibility
# sort by conjugate index:
data.sortedByBoth <- data.sortedByFlexibility[order(data.sortedByFlexibility$idxBoth, decreasing = F),]
return(data.sortedByBoth)
}
circuit_metrics.sim.sorted <- sortByTwoIndices.avgDist_and_flex(circuit_metrics.sim)
write.csv(circuit_metrics.sim.sorted,
file = './results/summary.circuits.sim.sortedByAvgDist_flex.csv',
row.names = T, quote = F)
remove(list = ls())
circuit_metrics.sim <- read.csv(file = './results/summary.circuits.sim.sigVal.csv', row.names = 1)
source('./functions.R')
outdir <- './results/'
circuit_metrics.sim.sorted <- sortByThreeIndices(circuit_metrics.sim)
View(circuit_metrics.sim.sorted)
View(circuit_metrics.sim.sorted)
rownames(circuit_metrics.sim.sorted) =="50-0.09-0.75"
sum(rownames(circuit_metrics.sim.sorted) =="50-0.09-0.75")
sum(rownames(circuit_metrics.sim.sorted) =="0.09-50-0.75")
remove(list = ls())
PERCENT_REDUCTION <- 90
library(sRACIPE)
source('./functions.R')
circuits <- readRDS('./circuits/circuits.uniq.rds')
names(circuits)
flexibility.df <- as.data.frame(matrix(nrow = length(circuits), ncol = 2))
names(circuits)
flexibility.df <- as.data.frame(matrix(nrow = length(circuits), ncol = 2))
View(flexibility.df)
colnames(flexibility.df) <- c('circuit.idx', 'flexibility')
rownames(flexibility.df) <- names(circuits)
for(circuit_idx in names(circuits)){
#circuit_idx <- names(circuits)[1]
#circuit_idx <- '0.16-16-0.8' #'0.07-20-0.8' #'0.07-12-0.8' #'0.07-12-0.85' #'0.06-20-0.8' #'0.06-16-0.8' #'0.06-12-0.8'
print(circuit_idx)
# Obtain simulated data:
racipe <- readRDS(file = paste('./circuits.sim/circuit_simulated_',
circuit_idx, '.rds', sep = ''))
racipe <- sRACIPE::sracipeNormalize(racipe)
# KD by subsetting:
racipe.kd <- sRACIPE::sracipeKnockDown(racipe, plotToFile = FALSE,
plotBarPlot = FALSE, #TRUE,
plotHeatmap = FALSE,
reduceProduction = (100-PERCENT_REDUCTION)
)
avg.dist <- calDistance(racipe.kd)
flexibility.df[circuit_idx, ] <- c(circuit_idx, avg.dist)
break()
}
avg.dist
remove(list = ls())
circuit_metrics.sim <- read.csv(file = './results/summary.circuits.sim.sortedByAcc_flex.csv', row.names = 1)
remove(list = ls())
MINIMUM.CIRCUIT.SIZE <- 15
circuit_metrics.sim <- read.csv(file = './results/summary.circuits.sim.sortedByAcc_flex.csv', row.names = 1)
outdir <- './results/'
remove(list = ls())
MINIMUM.CIRCUIT.SIZE <- 15
circuit_metrics.sim <- read.csv(file = './results/summary.circuits.sim.sortedByAcc_flex.csv', row.names = 1)
outdir <- './results/'
tmp <- circuit_metrics.sim[circuit_metrics.sim$Nodes>=MINIMUM.CIRCUIT.SIZE, ]
View(tmp)
View(circuit_metrics.sim)
circuit_metrics.sim <- circuit_metrics.sim[circuit_metrics.sim$Nodes>=MINIMUM.CIRCUIT.SIZE, ]
write.csv(circuit_metrics.sim.sorted,
file = './results/summary.circuits.sim.sortedByAcc_flex.nodes-15orMore.csv',
row.names = T, quote = F)
circuit_metrics.sim <- read.csv(file = './results/summary.circuits.sim.sortedByAcc_flex.csv', row.names = 1)
circuit_metrics.sim.tmp <- circuit_metrics.sim[circuit_metrics.sim$Nodes>=MINIMUM.CIRCUIT.SIZE, ]
write.csv(circuit_metrics.sim.tmp,
file = './results/summary.circuits.sim.sortedByAcc_flex.nodes-15orMore.csv',
row.names = T, quote = F)
#!/usr/bin/env Rscript
# Resources:
# 1. http://r-statistics.co/Linear-Regression.html
remove(list = ls())
MINIMUM.CIRCUIT.SIZE <- 15
outdir <- './results/'
circuit_metrics.sim <- read.csv(file = './results/summary.circuits.sim.sortedByAcc_flex.csv', row.names = 1)
circuit_metrics.sim.tmp <- circuit_metrics.sim[circuit_metrics.sim$Nodes>=MINIMUM.CIRCUIT.SIZE, ]
write.csv(format(circuit_metrics.sim.tmp, digits = 2),
file = './results/summary.circuits.sim.sortedByAcc_flex.nodes-15orMore.csv',
row.names = T, quote = F)
remove(list = ls())
NUM_CLUSTERS <- 2
library(igraph)
library(NetAct)
library(sRACIPE)
source('./functions.R')
source('./heatmapSimilarity.updated.R')
library(dplyr)
outdir.hS <- './circuits.hS/'
dir.create(outdir.hS)
outdir <- './results/'
dir.create(outdir)
circuit_metrics <- read.csv(file = './circuits/summary.circuits.csv', row.names = 1)
dim(circuit_metrics)
circuit_metrics.sim <- circuit_metrics[!circuit_metrics$DupStatus,]
dim(circuit_metrics)
circuits <- readRDS('./circuits/circuits.uniq.rds')
names(circuits)
circuits <- readRDS('./circuits/circuits.uniq.rds')
names(circuits)
length(names(circuits))
View(circuit_metrics.sim)
names(circuits)
View(circuit_metrics.sim)
circuit_metrics.sim
circuit_metrics.sim <- circuit_metrics.sim[circuit_metrics.sim$Nodes>=MINIMUM.CIRCUIT.SIZE, ]
MINIMUM.CIRCUIT.SIZE <- 15
circuit_metrics.sim <- circuit_metrics.sim[circuit_metrics.sim$Nodes>=MINIMUM.CIRCUIT.SIZE, ]
dim(circuit_metrics.sim)
rownames(circuit_metrics.sim)
getwd()
NO_SAMPLES <- 1000
SAMPLE_SIZE <- 10000
PERCENT_REDUCTION <- 90
